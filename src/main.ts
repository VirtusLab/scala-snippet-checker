import * as cli from '@actions/exec'
import * as core from '@actions/core'
import * as github from '@actions/github'
import * as tc from '@actions/tool-cache'

const scalaCLIVersion = '0.1.5'
const headerInfo = 'Generated by GithubAction - Scala Snippet Runner'
const octokit = github.getOctokit(core.getInput('token'))
core.exportVariable('INPUT_TOKEN', undefined) // hide Github Token before running Scala code

interface GithubContext {
  body: string
  html_url: string
  source_id: number
  issueNumber: number
}

interface Snippet {
  mdSnippet: string
  code: string
  scalaCliOptions: string[]
}

async function execOutput(
  cmd: string,
  stdin: string,
  args: string[]
): Promise<string> {
  let output = ''
  const options: cli.ExecOptions = {
    input: Buffer.from(stdin, 'utf8'),
    ignoreReturnCode: true,
    listeners: {
      stdout: (data: Buffer) => {
        output += data.toString()
      },
      stderr: (data: Buffer) => {
        output += data.toString()
      }
    }
  }
  await cli.exec(cmd, args, options)
  return output.trim()
}

async function downloadScalaCli(): Promise<string> {
  const baseUrl = `https://github.com/VirtusLab/scala-cli/releases/download/v${scalaCLIVersion}/scala-cli-x86_64`
  let scalaCliBinary = ''
  switch (process.platform) {
    case 'linux': {
      const guid = await tc.downloadTool(`${baseUrl}-pc-linux.gz`)
      const arc = `${guid}.gz`
      await cli.exec('mv', [guid, arc])
      scalaCliBinary = arc
      break
    }
    default:
      core.setFailed(`Unknown process.platform: ${process.platform}`)
  }
  if (!scalaCliBinary) core.setFailed(`Couldn't download ScalaCLI`)
  if (scalaCliBinary.endsWith('.gz')) {
    await cli.exec('gzip', ['-d', scalaCliBinary])
    scalaCliBinary = scalaCliBinary.slice(
      0,
      scalaCliBinary.length - '.gz'.length
    )
  }
  await cli.exec('chmod', ['+x', scalaCliBinary])
  return scalaCliBinary
}

async function scalaCLI(args: string[]): Promise<string> {
  const previous = tc.find('scala-cli', scalaCLIVersion)
  if (previous) {
    core.addPath(previous)
  } else {
    const scalaCLIBinary = await downloadScalaCli()
    const binaryName =
      process.platform === 'win32' ? 'scala-cli.exe' : 'scala-cli'
    const scalaCLICached = await tc.cacheFile(
      scalaCLIBinary,
      binaryName,
      'scala-cli',
      scalaCLIVersion
    )
    core.addPath(scalaCLICached)
  }
  return execOutput('scala-cli', '', args)
}

function extractGithubContext(): GithubContext {
  let ctx = {} as GithubContext
  let issueNumber = 0
  if (github.context.payload.issue) {
    issueNumber = github.context.payload.issue.number
  }

  switch (github.context.eventName) {
    case 'issue_comment': {
      if (github.context.payload.comment) {
        ctx = {
          body: github.context.payload.comment.body,
          html_url: github.context.payload.comment.html_url,
          source_id: github.context.payload.comment.id,
          issueNumber
        }
      }
      break
    }
    case 'issues': {
      if (github.context.payload.issue) {
        ctx = {
          body: github.context.payload.issue.body || '',
          html_url: github.context.payload.issue.html_url || '',
          source_id: github.context.payload.issue.id,
          issueNumber
        }
      }
      break
    }
    default:
      core.info(`Unknown event: ${github.context.eventName}`)
  }
  return ctx
}

async function markCommentAsUpdating(
  repo: string[],
  toUpdateComment: number
): Promise<void> {
  try {
    const comment = await octokit.rest.issues.getComment({
      owner: repo[0],
      repo: repo[1],
      comment_id: toUpdateComment
    })

    const body = `Updating snippets in progress ...\n${comment.data.body || ''}`
    await octokit.rest.issues.updateComment({
      owner: repo[0],
      repo: repo[1],
      comment_id: toUpdateComment,
      body
    })
  } catch (error) {
    return
  }
}

async function findGeneratedCommentByBotId(
  repo: string[],
  ghContext: GithubContext
): Promise<number> {
  const issueComments = await octokit.rest.issues.listComments({
    owner: repo[0],
    repo: repo[1],
    issue_number: ghContext.issueNumber
  })

  const commentIdRegex = new RegExp('(id):([0-9]+)')

  const commentsId: Map<string, number> = new Map(
    issueComments.data.map(comment => {
      const body = comment.body || ''
      const match = commentIdRegex.exec(body)
      let id = ''
      if (match != null) {
        id = match[2]
      }
      return [id, comment.id]
    })
  )

  const toUpdateCommentId = commentsId.get(ghContext.source_id.toString()) || 0
  return toUpdateCommentId
}

async function createComment(
  comment: string,
  repo: string[],
  ghContext: GithubContext,
  toUpdateCommentId: number
): Promise<void> {
  if (toUpdateCommentId !== 0) {
    await octokit.rest.issues.updateComment({
      owner: repo[0],
      repo: repo[1],
      comment_id: toUpdateCommentId,
      body: comment
    })
  } else {
    await octokit.rest.issues.createComment({
      owner: repo[0],
      repo: repo[1],
      issue_number: ghContext.issueNumber,
      body: comment
    })
  }
}

function generateCommentHeader(ghContext: GithubContext): string {
  const header = `<!--\n${headerInfo}\nid:${ghContext.source_id}\n-->\n`
  return header
}

function isAllowedEvent(): boolean {
  return (
    github.context.eventName === 'issue_comment' ||
    github.context.eventName === 'issues'
  )
}

function isCreatedByBot(): Boolean {
  if (github.context.payload.comment) {
    const body: string = github.context.payload.comment.body
    return body.includes(headerInfo)
  } else {
    return false
  }
}

function getSnippet(ghContext: GithubContext): Snippet[] {
  const snippets: Snippet[] = []

  const regex = new RegExp('```.*?(scala-cli(.*)([^]*?))```', 'g')
  let match = regex.exec(ghContext.body)

  while (match != null) {
    const mdSnippet = match[0]
    const code = match[3]
    const scalaCliOptions = match[2].trim().split(/[ ,]+/).concat(['-q', '-'])

    snippets.push({
      mdSnippet,
      code,
      scalaCliOptions
    })

    match = regex.exec(ghContext.body)
  }
  return snippets
}

async function run(): Promise<void> {
  if (!isAllowedEvent() || isCreatedByBot()) {
    return
  }
  try {
    const ghContext = extractGithubContext()
    const repo = (process.env.GITHUB_REPOSITORY as string).split('/')

    const createdCommentByBotIdOpt = await findGeneratedCommentByBotId(
      repo,
      ghContext
    )

    let snippets: Snippet[] = []

    await core.group('Search snippets', async () => {
      snippets = getSnippet(ghContext)
    })

    if (snippets.length === 0) {
      core.debug('Not found snippets in a comment.')
      return
    }

    let bodyComment = ''
    bodyComment += generateCommentHeader(ghContext)

    if (snippets.length !== 0) {
      bodyComment += `In: ${ghContext.html_url}\n`
      bodyComment += 'Found following snippets: \n'

      await markCommentAsUpdating(repo, createdCommentByBotIdOpt)
    }

    await core.group('Install ScalaCLI', async () => {
      await scalaCLI(['--help'])
    })

    const maxLineLength = parseInt(core.getInput('max-lines'))

    await core.group('Run snippets', async () => {
      for (const snippet of snippets) {
        let output = await execOutput(
          'scala-cli',
          snippet.code,
          snippet.scalaCliOptions
        )
        output = output.replace(/\u001b\[.*?m/g, '')

        if (output.split(/\r\n|\r|\n/).length > maxLineLength) {
          bodyComment += `\n<br />Snippet:\n${snippet.mdSnippet}\n <details><summary>Click to show output!</summary>\n\n\`\`\`\n${output}\n\`\`\`\n</details>\n\n`
        } else {
          bodyComment += `\n<br />Snippet:\n${snippet.mdSnippet}\n Output:\n\`\`\`\n${output}\n\`\`\`\n\n`
        }
      }
    })

    await createComment(bodyComment, repo, ghContext, createdCommentByBotIdOpt)
  } catch (error) {
    if (error instanceof Error) core.setFailed(error.message)
  }
}

run()
